<?xml version="1.0"?>

<st-source>
<!-- 
Name: ChromiumEmbeddedFramework-UI
Notice: Licensed under the MIT license

Copyright (c) 2017 Holger Kleinsorgen

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
Comment: Chromium Embedded Framework (CEF) for VisualWorks.
Displays a browser inside a VW view.

See 
https://bitbucket.org/chromiumembedded/cef

Still at an very early stage. 
Windows only.

Open an examle app with:
  CEF.BrowserUI open

Based on CEF 3.3112.1659.gfef43e0 (2017-09-06)

Contact: h . kleinsorgen - at - gmail . com

Licensed under the MIT license (see Copyright)
DevelopmentPrerequisites: #(#(#any 'ChromiumEmbeddedFramework-Base' ''))
KSignature: #('definedClasses' 16 'definedClassesHash' 20756352041 'extendedClasses' 2 'extendedClassesHash' 228269851)
KSignatureV2: #('definedClasses' 16 'definedClassesHash' 916998915262710391338275912155603339465865689928 'extendedClasses' 2 'extendedClassesHash' 849294146091889771366534880515470931888282031258)
PackageName: ChromiumEmbeddedFramework-UI
Parcel: #('ChromiumEmbeddedFramework-UI')
ParcelDirectory: e:\develop\git\cef\parcels\ChromiumEmbeddedFramework-UI
PrerequisiteDescriptions: #(#(#name 'ChromiumEmbeddedFramework-Base' #componentType #package))
PrerequisiteParcels: #(#('ChromiumEmbeddedFramework-Base' ''))
Version: 0.1.24
Date: 2:53:15 PM September 16, 2017
 -->
<time-stamp>From VisualWorks®, 8.1.1 of 10. März 2016 on 16. September 2017 at 14:53:15</time-stamp>


<do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it>

<class>
<name>Base</name>
<environment>CEF</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>osLib externals callbacks isVolatile </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.Base</class-id>
<body>Base class for CEF wrappers</body>
</comment>

<class>
<name>SchemeRegistrar</name>
<environment>CEF</environment>
<super>CEF.Base</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>Frame</name>
<environment>CEF</environment>
<super>CEF.Base</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.Frame</class-id>
<body>Wraps a frame of a browser.</body>
</comment>

<class>
<name>Settings</name>
<environment>CEF</environment>
<super>CEF.Base</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>LifecycleBase</name>
<environment>CEF</environment>
<super>CEF.Base</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>lifecycle </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>BrowserHost</name>
<environment>CEF</environment>
<super>CEF.Base</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>ScheduledWork</name>
<environment>CEF</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>targetTime delay timer isScheduled </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>PumpWork</name>
<environment>CEF</environment>
<super>CEF.ScheduledWork</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>ResizeWork</name>
<environment>CEF</environment>
<super>CEF.ScheduledWork</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>browser </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>Client</name>
<environment>CEF</environment>
<super>CEF.LifecycleBase</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>areaPart browser </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>Browser</name>
<environment>CEF</environment>
<super>CEF.LifecycleBase</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>client </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.Browser</class-id>
<body>Browser wrapper</body>
</comment>

<class>
<name>BrowserAreaPart</name>
<environment>CEF</environment>
<super>Graphics.VisualPart</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.BrowserAreaPart</class-id>
<body>The area covered by the browser. The only purpose of this view is to trigger events.</body>
</comment>

<class>
<name>BrowserUI</name>
<environment>CEF</environment>
<super>UI.ApplicationModel</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>urlAspect areaPart client </inst-vars>
<class-inst-vars></class-inst-vars>
<imports>
			Graphics.*
			UI.*
			</imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.BrowserUI</class-id>
<body>A bare bones browser app</body>
</comment>

<class>
<name>MainMessageLoop</name>
<environment>CEF</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>messageProcess loopSemaphore minimalDelay scheduledWork scheduleLock </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>Log</name>
<environment>CEF</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>logProcess logQueue debug </inst-vars>
<class-inst-vars>current </class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<class>
<name>MainApp</name>
<environment>CEF</environment>
<super>CEF.LifecycleBase</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>messageLoop </inst-vars>
<class-inst-vars>current </class-inst-vars>
<imports></imports>
<category></category>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</class>

<comment>
<class-id>CEF.MainApp</class-id>
<body>Wraps the main application. This is a singleton which can only be initialized once per OS process.</body>
</comment>

<shared-variable>
<name>DefaultURL</name>
<environment>CEF.BrowserUI</environment>
<private>false</private>
<constant>false</constant>
<category>accessing</category>
<initializer></initializer>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</shared-variable>

<shared-variable>
<name>Registry</name>
<environment>CEF.Base</environment>
<private>false</private>
<constant>false</constant>
<category>accessing</category>
<initializer>nil</initializer>
<attributes>
<package>ChromiumEmbeddedFramework-UI</package>
</attributes>
</shared-variable>

<methods>
<class-id>CEF.Base class</class-id> <category>pragmas</category>

<body package="ChromiumEmbeddedFramework-UI">callbackPragmas	&lt;pragmas: #instance&gt;		^ #(		callback:		callback:handler:	)</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>events-lifespan</category>

<body package="ChromiumEmbeddedFramework-UI">onAfterCreated: aBrowser 	&lt;callback: #'on_after_created' handler: #'get_life_span_handler'&gt;		browser := aBrowser.	" aBrowser is a volatile argument, so register now "	browser register.	browser client: self.	self areaPart when: #resized send: #resized to: browser.	self areaPart when: #released send: #stop to: self.	self triggerEvent: #createdBrowser.</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>events-load</category>

<body package="ChromiumEmbeddedFramework-UI">onLoadEnd: theBrowser frame: frame statusCode: statusCode 	&lt;callback: #'on_load_end' handler: #'get_load_handler'&gt;		self triggerEvent: #loaded with: frame with: statusCode.</body>

<body package="ChromiumEmbeddedFramework-UI">onLoadError: theBrowser frame: frame errorCode: errorCode errorText: errorText failedUrl: failedUrl 	&lt;callback: #'on_load_error' handler: #'get_load_handler'&gt;		| arguments |	arguments := OrderedCollection new: 4.	arguments add: frame.	arguments add: errorCode.	arguments add: errorText cefAsString.	arguments add: failedUrl cefAsString.	self triggerEvent: #loadError withArguments: arguments asArray</body>

<body package="ChromiumEmbeddedFramework-UI">onLoadStart: cefBrowser frame: frame transitionType: transitionType 	&lt;callback: #'on_load_start' handler: #'get_load_handler'&gt;		self triggerEvent: #loading with: frame with: transitionType.</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>events-focus</category>

<body package="ChromiumEmbeddedFramework-UI">onGotFocus: theBrowser	&lt;callback: #'on_got_focus' handler: #'get_focus_handler'&gt;		self restoreFocus.</body>

<body package="ChromiumEmbeddedFramework-UI">onSetFocus: theBrowser source: source	&lt;callback: #'on_set_focus' handler: #'get_focus_handler'&gt;		self restoreFocus.	^ self lib RV_CONTINUE</body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">loadUrl: anUrl 	" convenience "		self mainFrame loadUrl: anUrl</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>events</category>

<body package="ChromiumEmbeddedFramework-UI">loadError: frame errorCode: errorCode errorUrl: errorUrl errorText: errorText 	Log debugLog: [ 'Load error ' , errorUrl , ': ' , errorText ].	frame isMain 		ifTrue: 		[	self urlColor: ColorValue orange.			self urlAspect value: frame url		].</body>

<body package="ChromiumEmbeddedFramework-UI">loading: frame 	Log debugLog: [ 'Loading ', frame url ].	frame isMain 		ifTrue: 		[				self urlColor: ColorValue lightGray.			self urlAspect value: frame url		].</body>
</methods>

<methods>
<class-id>CEF.BrowserUI class</class-id> <category>interface specs</category>

<body package="ChromiumEmbeddedFramework-UI">browserSpec	"Tools.UIPainter new openOnClass: self andSelector: #browserSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#bounds: #(#{Graphics.Rectangle} 640 347 1280 693 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #areaPart 					#flags: 0 					#component: #areaPart ) ) ) )</body>

<body package="ChromiumEmbeddedFramework-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 100 100 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 616 346 1616 946 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 80 0 30 0 ) 					#name: #loadUrl 					#model: #loadUrl 					#label: 'Go' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 85 0 5 0 140 0 30 0 ) 					#name: #stopLoad 					#model: #stopLoad 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 145 0 5 0 170 0 30 0 ) 					#name: #goBack 					#model: #goBack 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 175 0 5 0 200 0 30 0 ) 					#name: #goForward 					#model: #goForward 					#label: '&gt;' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 5 0 -5 1 30 0 ) 					#name: #urlAspect 					#model: #urlAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #loadUrl ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 35 0 0 1 0 1 ) 					#name: #browserSpec 					#flags: 0 					#minorKey: #browserSpec ) ) ) )</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>events-app</category>

<body package="ChromiumEmbeddedFramework-UI">onBeforeCommandLineProcessing: process_type commandLine: commandLine	&lt;callback: #on_before_command_line_processing&gt; 	self switches do: [: switch | commandLine cefCall: #'append_switch' with: switch ].</body>

<body package="ChromiumEmbeddedFramework-UI">onRegisterCustomSchemes: schemeRegistrar 	&lt;callback: #on_register_custom_schemes&gt; </body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>events-browser process handler</category>

<body package="ChromiumEmbeddedFramework-UI">onContextInitialized	&lt;callback: #on_context_initialized handler: #get_browser_process_handler&gt;		</body>

<body package="ChromiumEmbeddedFramework-UI">onScheduleMessagePumpWork: delay	&lt;callback: #on_schedule_message_pump_work handler: #get_browser_process_handler&gt;		self schedule: ( PumpWork delay: delay ).</body>
</methods>

<methods>
<class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category>

<body package="ChromiumEmbeddedFramework-UI">flushCEF	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	CEF.LibChromium flushCurrent.	CEF.MainApp flushCurrent.	CEF.Log stop.</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">initialize	callbacks := Set new.	self initializeExternals.</body>

<body package="ChromiumEmbeddedFramework-UI">initializeWrapped	" called once the associated CEF object is set / created "		self installCallbacks.</body>

<body package="ChromiumEmbeddedFramework-UI">release	self initializeExternals</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>callbacks-private</category>

<body package="ChromiumEmbeddedFramework-UI">callbackBlockForArguments: numberOfArguments selector: selector 	numberOfArguments = 0 		ifTrue: 		[	^ [	self debugCallback: selector.				self perform: selector			]		].	numberOfArguments = 1 		ifTrue: 		[	^ [: myself |				self debugCallback: selector.				self perform: selector			]		].	numberOfArguments = 2 		ifTrue: 		[	^ [: myself : a1 |				self debugCallback: selector.				self performCallback: selector arguments: ( Array with: a1 )			]		].	numberOfArguments = 3 		ifTrue: 		[	^ [: myself : a1 : a2 |				self debugCallback: selector.				self performCallback: selector arguments: ( Array with: a1 with: a2 )			]		].	numberOfArguments = 4 		ifTrue: 		[	^ [: myself : a1 : a2 : a3 |				self debugCallback: selector.				self performCallback: selector arguments: ( Array with: a1 with: a2 with: a3 )			]		].	numberOfArguments = 5 		ifTrue: 		[	^ [: myself : a1 : a2 : a3 : a4 | | args |				self debugCallback: selector.				args := ( OrderedCollection new: 4 )						add: a1;						add: a2;						add: a3;						add: a4;						asArray.				self performCallback: selector arguments: args			]		].	numberOfArguments = 6 		ifTrue: 		[	^ [: myself : a1 : a2 : a3 : a4 : a5 | | args |				self debugCallback: selector.				args := ( OrderedCollection new: 5 )						add: a1;						add: a2;						add: a3;						add: a4;						add: a5;						asArray.				self performCallback: selector arguments: args			]		].	self error: 'unsupported number of callback arguments, ' , numberOfArguments printString.</body>

<body package="ChromiumEmbeddedFramework-UI">cefReleaseCallbackArg	" volatile arguments are not registered, so release now "	self isVolatile 		ifTrue: [ self release ].</body>

<body package="ChromiumEmbeddedFramework-UI">debugCallback: selector	Log debugLog: 'Callback: ', selector</body>

<body package="ChromiumEmbeddedFramework-UI">installCallbackFromPragma: pragma 	self installCallbackFromPragma: pragma on: self cefObject</body>

<body package="ChromiumEmbeddedFramework-UI">installCallbackFromPragma: pragma on: cefObject 	| numberOfArguments callbackProtoype block memberName selector |	memberName := pragma argumentAt: 1.	Log debugLog: 'Installing callback ' , memberName.	callbackProtoype := cefObject 			cefMemberAt: memberName			ifAbsent: [ self error: 'Callback ' , memberName , ' not found' ].	numberOfArguments := callbackProtoype type referentType numArgs.	selector := pragma selector.	selector numArgs = ( numberOfArguments - 1 ) 		ifFalse: 		[	self error: ( numberOfArguments - 1 ) printString , ' arguments expected for #' , selector		].	block := self callbackBlockForArguments: numberOfArguments selector: selector.	self createCallback: block named: memberName of: cefObject.</body>

<body package="ChromiumEmbeddedFramework-UI">installCallbacks	| handlerPragmas |	" callbacks of the object "	( Tools.Pragma allNamed: #callback: from: self class to: Base ) 		do: [: pragma | self installCallbackFromPragma: pragma ].	" generic handlers that dont require a separate wrapper object "	handlerPragmas := Tools.Pragma allNamed: #callback:handler: from: self class to: Base.	( handlerPragmas groupedBy: [: pragma | pragma argumentAt: 2 ]) keysAndValuesDo: 		[: handlerCallbackName : pragmas | | handler handlerType |			" get the handler signature from the callback  "			handlerType := ( self cefObject memberAt: handlerCallbackName ) resultType referentType.			" create a new handler an register all defined callbacks "			handler := self class createCefObjectOfType: handlerType.			pragmas do: [: pragma | self installCallbackFromPragma: pragma on: handler ].			self externalAt: handlerCallbackName put: handler.			" register the callback the returns the handler "			self createCallback: [ handler ] named: handlerCallbackName of: self cefObject		].</body>

<body package="ChromiumEmbeddedFramework-UI">performCallback: selector arguments: arguments 	| callbackArguments |	callbackArguments := arguments collect: [: a | a cefAsSmalltalkArg ].	^ [ self perform: selector withArguments: callbackArguments ] 		ensure: [ callbackArguments do: [: arg | arg cefReleaseCallbackArg ]]</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>calls</category>

<body package="ChromiumEmbeddedFramework-UI">call: memberFunctionName 	^ self call: memberFunctionName arguments: #()</body>

<body package="ChromiumEmbeddedFramework-UI">call: memberFunctionName arguments: arguments 	^ self cefObject cefCall: memberFunctionName arguments: arguments </body>

<body package="ChromiumEmbeddedFramework-UI">call: memberFunctionName with: anArgument	^ self cefObject cefCall: memberFunctionName with: anArgument</body>

<body package="ChromiumEmbeddedFramework-UI">call: memberFunctionName with: anArgument1 with: anArgument2	^ self cefObject cefCall: memberFunctionName with: anArgument1 with: anArgument2</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>externals-utilities</category>

<body package="ChromiumEmbeddedFramework-UI">createCallback: block named: memberName of: cefObject	| newCallback |	newCallback := cefObject cefCallbackNamed: memberName set: block.	" store callbacks to avoid gc "	callbacks add: newCallback.	^ newCallback</body>

<body package="ChromiumEmbeddedFramework-UI">enumNamed: enumName of: memberName 	^ ( self enumTypeOfMemberAt: memberName ) memberNamed: enumName</body>

<body package="ChromiumEmbeddedFramework-UI">enumTypeOfMemberAt: memberName 	^ ( self cefObject refMemberAt: memberName ) type referentType</body>

<body package="ChromiumEmbeddedFramework-UI">fakeRefCount: cefObject 	" fake ref count that never releases stuff "	| refCount base |	self isVolatile 		ifTrue: 		[	" .. except if this is a volatile object (usually a callback argument) "			^ self		].	base := cefObject cefMemberAt: #base ifAbsent: [ nil ].	( base notNil and: [( base cefMemberAt: #'add_ref' ifAbsent: [ nil ]) notNil ]) 		ifTrue: 		[	refCount := 0.			self createCallback: [: s | refCount := refCount + 1 ] named: #'add_ref' of: base.			self 				createCallback: 				[: s |					refCount := refCount - 1.					1				]				named: #release				of: base.			self createCallback: [: s | 1 ] named: #'has_one_ref' of: base.			cefObject cefMemberAt: #base put: base		].</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>finalization</category>

<body package="ChromiumEmbeddedFramework-UI">actAsExecutor	callbacks := #()</body>

<body package="ChromiumEmbeddedFramework-UI">executor	^ self shallowCopy actAsExecutor</body>

<body package="ChromiumEmbeddedFramework-UI">finalize	"Log debugLog: 'Finalize ', self printString."	self release.</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">cefObject	^ self externalAt: #cefObject ifAbsent: [ self error: 'Object has been released' ]</body>

<body package="ChromiumEmbeddedFramework-UI">cefObject: aCefCompositePointer	self externalAt: #cefObject put: aCefCompositePointer.</body>

<body package="ChromiumEmbeddedFramework-UI">debug	^ Log current debug</body>

<body package="ChromiumEmbeddedFramework-UI">isAlive	" true if my CEF object is still alive "	| pointer |	pointer := self externalAt: #cefObject ifAbsent: [ nil ].	^ pointer notNil and: [ pointer isValid ]</body>

<body package="ChromiumEmbeddedFramework-UI">isVolatile	^ isVolatile ifNil: [ false ]</body>

<body package="ChromiumEmbeddedFramework-UI">isVolatile: aBoolean 	isVolatile := aBoolean.</body>

<body package="ChromiumEmbeddedFramework-UI">key	" key for the handle registry " 		^ self cefObject ifNotNil: [: c | c referentAddress ]</body>

<body package="ChromiumEmbeddedFramework-UI">lib	^ LibChromium current </body>

<body package="ChromiumEmbeddedFramework-UI">mainApp	^ MainApp current</body>

<body package="ChromiumEmbeddedFramework-UI">osLib	osLib isNil 		ifTrue: [ osLib := OSSystemSupport concreteClass new ].	^ osLib</body>

<body package="ChromiumEmbeddedFramework-UI">register	self isVolatile 		ifTrue: 		[	self isVolatile: false.			self fakeRefCount: self cefObject		].	self class registry registerValueOf: [ self ].</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>externals-private</category>

<body package="ChromiumEmbeddedFramework-UI">externalAt: aSymbol 	^ externals at: aSymbol ifAbsent: [ nil ]</body>

<body package="ChromiumEmbeddedFramework-UI">externalAt: aSymbol ifAbsent: aBlock	^ externals at: aSymbol ifAbsent: aBlock</body>

<body package="ChromiumEmbeddedFramework-UI">externalAt: aSymbol ifAbsentPut: aBlock 	^ externals 		at: aSymbol		ifAbsentPut: 		[ | ext |			ext := aBlock value.			self fakeRefCount: ext.			ext		]</body>

<body package="ChromiumEmbeddedFramework-UI">externalAt: aSymbol put: anExternal 	externals at: aSymbol put: anExternal.	self fakeRefCount: anExternal.</body>

<body package="ChromiumEmbeddedFramework-UI">initializeExternals	externals := Dictionary new.</body>

<body package="ChromiumEmbeddedFramework-UI">removeExternalAt: aSymbol 	externals removeKey: aSymbol ifAbsent: [ nil ]</body>
</methods>

<methods>
<class-id>CEF.Base</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">booleanAt: key	^ self memberAt: key convertedWith: [ : int | int cefAsBoolean]</body>

<body package="ChromiumEmbeddedFramework-UI">enumAt: memberName 	^ ( self cefObject cefMemberAt: memberName ) ifNotNil: 		[: value | | enum |			enum := self enumTypeOfMemberAt: memberName.			enum cefNameOf: value		].</body>

<body package="ChromiumEmbeddedFramework-UI">enumAt: memberName put: enumName	| enumValue |	enumValue := self enumNamed: enumName of: memberName.	self memberAt: memberName put: enumValue.</body>

<body package="ChromiumEmbeddedFramework-UI">memberAt: aKey	^ self memberAt: aKey convertedWith: [ : value | value cefAsSmalltalkArg ]</body>

<body package="ChromiumEmbeddedFramework-UI">memberAt: aKey convertedWith: aBlock	^ (self cefObject cefMemberAt: aKey ) ifNotNil: [ : value | aBlock value: value ]</body>

<body package="ChromiumEmbeddedFramework-UI">memberAt: aKey put: aValue	self cefObject cefMemberAt: aKey put: aValue asCefDatum</body>
</methods>

<methods>
<class-id>CEF.Base class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">type	^ self typeName ifNotNil: [ : typeName | CEF.LibChromium current perform: typeName ]</body>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ nil</body>
</methods>

<methods>
<class-id>CEF.Base class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">new	^ super new initialize</body>

<body package="ChromiumEmbeddedFramework-UI">on: aCefObject 	^ self on: aCefObject isVolatile: false</body>

<body package="ChromiumEmbeddedFramework-UI">onNewObject	^ self on: self createCefObject</body>
</methods>

<methods>
<class-id>CEF.Base class</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">classForType: aType 	^ self allSubclasses 		detect: [: class | class type ifNotNil: [: classType | classType = aType or: [classType type = aType ] ] ifNil: [ false ]]		ifNone: [ nil ]</body>

<body package="ChromiumEmbeddedFramework-UI">createCefObject	| type |	type := self typeName.	type isNil 		ifTrue: [ self error: 'Cannot create objects of class ' , self fullName ].	^ self createCefObjectOfTypeNamed: type</body>

<body package="ChromiumEmbeddedFramework-UI">createCefObjectOfType: type 	| cefObject base sizeof size |	cefObject := type malloc.	cefObject zeroFill.	" initialize common members "	sizeof := cefObject type referentType sizeof.	base := cefObject cefMemberAt: #base ifAbsent: [ nil ].	base notNil 		ifTrue: 		[	base cefMemberAt: #size put: sizeof.			cefObject cefMemberAt: #base put: base		]		ifFalse: 		[	size := cefObject cefMemberAt: #size ifAbsent: [ nil ].			size notNil 				ifTrue: [ cefObject cefMemberAt: #size put: sizeof ]		].	^ cefObject</body>

<body package="ChromiumEmbeddedFramework-UI">createCefObjectOfTypeNamed: typeName 	^ self createCefObjectOfType: ( CEF.LibChromium current perform: typeName )</body>

<body package="ChromiumEmbeddedFramework-UI">on: aCefObject isVolatile: isVolatile 	| registeredObject newObject |	" try to return the same object "	registeredObject := self registry at: aCefObject cefRegistryKey.	registeredObject notNil 		ifTrue: [ ^ registeredObject ].	newObject := self new			isVolatile: isVolatile;			cefObject: aCefObject;			initializeWrapped;			yourself.	isVolatile 		ifFalse: [ newObject register ].	^ newObject</body>

<body package="ChromiumEmbeddedFramework-UI">registry	Registry isNil 		ifTrue: [ Registry := HandleRegistry new ].	^ Registry</body>
</methods>

<methods>
<class-id>CEF.SchemeRegistrar</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">addCustomScheme: schemeName flags: flagSymbols 	| arguments |	arguments := OrderedCollection new.	arguments add: schemeName asCefDatum.	arguments add: ( flagSymbols includes: #standard ) asCefDatum.	arguments add: ( flagSymbols includes: #displayIsolated ) asCefDatum.	arguments add: ( flagSymbols includes: #secure ) asCefDatum.	arguments add: ( flagSymbols includes: #corsEnabled ) asCefDatum.	arguments add: ( flagSymbols includes: #cspBypassing ) asCefDatum.	self call: #'add_custom_scheme' arguments: arguments.</body>
</methods>

<methods>
<class-id>CEF.SchemeRegistrar class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_scheme_registrar_t</body>
</methods>

<methods>
<class-id>CEF.Frame</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">isMain	^ ( self call: #'is_main' ) cefAsBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">isValid	^ ( self call: #isValid ) cefAsBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">loadUrl: anUrl 	self call: #'load_url' with: anUrl.</body>

<body package="ChromiumEmbeddedFramework-UI">name	^ ( self call: #'get_name' ) cefAsString</body>

<body package="ChromiumEmbeddedFramework-UI">url	^ ( self call: #'get_url' ) cefAsString</body>
</methods>

<methods>
<class-id>CEF.Frame class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_frame_t</body>
</methods>

<methods>
<class-id>CEF.Settings</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">externalMessagePump	^ self booleanAt: #external_message_pump</body>

<body package="ChromiumEmbeddedFramework-UI">externalMessagePump: aBoolean	self memberAt: #external_message_pump put: aBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">logFile	^ self memberAt: #log_file</body>

<body package="ChromiumEmbeddedFramework-UI">logFile: aString	self memberAt: #log_file put: aString</body>

<body package="ChromiumEmbeddedFramework-UI">logSeverity	^ self enumAt: #log_severity </body>

<body package="ChromiumEmbeddedFramework-UI">logSeverity: aSymbol	self enumAt: #log_severity put: aSymbol</body>

<body package="ChromiumEmbeddedFramework-UI">multiThreadedMessageLoop	^ self booleanAt: #multi_threaded_message_loop</body>

<body package="ChromiumEmbeddedFramework-UI">multiThreadedMessageLoop: aBoolean	self memberAt: #multi_threaded_message_loop put: aBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">noSandbox	^ self booleanAt: #no_sandbox </body>

<body package="ChromiumEmbeddedFramework-UI">noSandbox: aBoolean	self memberAt: #no_sandbox put: aBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">singleProcess	^ self booleanAt: #single_process</body>

<body package="ChromiumEmbeddedFramework-UI">singleProcess: aBoolean	self memberAt: #single_process put: aBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">userAgent	^ self memberAt: #user_agent</body>

<body package="ChromiumEmbeddedFramework-UI">userAgent: aString	self memberAt: #user_agent put: aString</body>
</methods>

<methods>
<class-id>CEF.Settings class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_settings_t</body>
</methods>

<methods>
<class-id>CEF.LifecycleBase</class-id> <category>lifecycle</category>

<body package="ChromiumEmbeddedFramework-UI">ensureIsRunning	self isRunning 		ifFalse: [ self start ].</body>

<body package="ChromiumEmbeddedFramework-UI">start	self isReleased 		ifTrue: [ self error: 'Already released' ].	self isRunning 		ifTrue: [ self error: 'Already running' ].	self doStart.	lifecycle := #running.</body>

<body package="ChromiumEmbeddedFramework-UI">stop	self isReleased 		ifFalse: 		[	self doStop.			self initializeExternals.			lifecycle := #released		].</body>
</methods>

<methods>
<class-id>CEF.LifecycleBase</class-id> <category>testing</category>

<body package="ChromiumEmbeddedFramework-UI">isReleased		^ lifecycle = #released</body>

<body package="ChromiumEmbeddedFramework-UI">isRunning		^ lifecycle = #running</body>
</methods>

<methods>
<class-id>CEF.LifecycleBase</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">initialize	super initialize.	lifecycle := #new.</body>

<body package="ChromiumEmbeddedFramework-UI">release	self stop.</body>
</methods>

<methods>
<class-id>CEF.LifecycleBase</class-id> <category>lifecycle-private</category>

<body package="ChromiumEmbeddedFramework-UI">doStart	self subclassResponsibility.</body>

<body package="ChromiumEmbeddedFramework-UI">doStop	self subclassResponsibility</body>
</methods>

<methods>
<class-id>CEF.BrowserHost</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">closeBrowserForce: force 	self call: #'close_browser' with: force.</body>

<body package="ChromiumEmbeddedFramework-UI">notifyMoveOrResizeStarted	self call: #'notify_move_or_resize_started'.</body>

<body package="ChromiumEmbeddedFramework-UI">tryCloseBrowser	self call: #'try_close_browser'.</body>

<body package="ChromiumEmbeddedFramework-UI">wasResized	self call: #'was_resized'.</body>
</methods>

<methods>
<class-id>CEF.BrowserHost class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_browser_host_t</body>
</methods>

<methods>
<class-id>CEF.ScheduledWork</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">delay	^ delay</body>

<body package="ChromiumEmbeddedFramework-UI">delay: milliseconds 	delay := milliseconds.</body>

<body package="ChromiumEmbeddedFramework-UI">isScheduled	^ isScheduled ifNil: [ false ].</body>

<body package="ChromiumEmbeddedFramework-UI">isScheduled: aIsScheduled 	isScheduled := aIsScheduled.</body>
</methods>

<methods>
<class-id>CEF.ScheduledWork</class-id> <category>comparing</category>

<body package="ChromiumEmbeddedFramework-UI">= anotherWork 	^ self class = anotherWork class and: [ self targetTime = anotherWork targetTime ]</body>

<body package="ChromiumEmbeddedFramework-UI">hash	^ targetTime hash</body>
</methods>

<methods>
<class-id>CEF.ScheduledWork</class-id> <category>work</category>

<body package="ChromiumEmbeddedFramework-UI">doWork	self subclassResponsibility</body>
</methods>

<methods>
<class-id>CEF.ScheduledWork</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">stopTimer	timer notNil 		ifTrue: 		[	timer stop.			timer := nil		].</body>

<body package="ChromiumEmbeddedFramework-UI">targetTime	^ targetTime</body>

<body package="ChromiumEmbeddedFramework-UI">targetTime: aTargetTime 	" set by the message loop "	targetTime := aTargetTime.</body>

<body package="ChromiumEmbeddedFramework-UI">timer	^ timer</body>

<body package="ChromiumEmbeddedFramework-UI">timer: aTimer 	timer := aTimer.</body>
</methods>

<methods>
<class-id>CEF.ScheduledWork class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">delay: milliseconds 	^ self new delay: milliseconds;		yourself</body>

<body package="ChromiumEmbeddedFramework-UI">fps: framesPerSecond	^ self delay: (1000 // framesPerSecond)</body>
</methods>

<methods>
<class-id>CEF.PumpWork</class-id> <category>work</category>

<body package="ChromiumEmbeddedFramework-UI">doWork	LibChromium current cef_do_message_loop_work</body>
</methods>

<methods>
<class-id>CEF.ResizeWork</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">browser	^ browser</body>

<body package="ChromiumEmbeddedFramework-UI">browser: aBrowser 	browser := aBrowser.</body>
</methods>

<methods>
<class-id>CEF.ResizeWork</class-id> <category>work</category>

<body package="ChromiumEmbeddedFramework-UI">doWork	self browser resizeBrowser</body>
</methods>

<methods>
<class-id>CEF.ResizeWork</class-id> <category>comparing</category>

<body package="ChromiumEmbeddedFramework-UI">= anotherWork 	^ super = anotherWork and: [ self browser = anotherWork browser ]</body>
</methods>

<methods>
<class-id>CEF.ResizeWork class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">browser: aBrowser 	^ ( self fps: 30)		browser: aBrowser;		yourself</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>factory</category>

<body package="ChromiumEmbeddedFramework-UI">createBrowserSettings	| settings |	settings := self lib cef_browser_settings_t malloc.	settings zeroFill.	settings memberAt: #size put: self lib cef_browser_settings_t sizeof.	^ settings</body>

<body package="ChromiumEmbeddedFramework-UI">createWindowInfo	| windowInfo style rectangle |	windowInfo := self lib cef_window_info_t malloc.	windowInfo zeroFill.	windowInfo memberAt: #'parent_window' put: self mainWindow windowHandle.	style := self lib WS_CHILD + self lib WS_CLIPCHILDREN + self lib WS_CLIPSIBLINGS + self lib WS_TABSTOP 			+ self lib WS_VISIBLE.	rectangle := self browserRectangle.	windowInfo memberAt: #x put: rectangle left.	windowInfo memberAt: #y put: rectangle top.	windowInfo memberAt: #width put: rectangle width.	windowInfo memberAt: #height put: rectangle height.	windowInfo memberAt: #style put: style.	^ windowInfo</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">browserRectangle	^ self areaPart globalBounds </body>

<body package="ChromiumEmbeddedFramework-UI">mainWindow	^ self areaPart topComponent</body>

<body package="ChromiumEmbeddedFramework-UI">restoreFocus	" CEF got the keyboard focus, let's take it back "	| win |	win := self mainWindow.	[	self osLib cefSetFocus: 0;			cefSetFocus: win windowHandle	] uiEventFor: win.</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">areaPart	^ areaPart</body>

<body package="ChromiumEmbeddedFramework-UI">areaPart: aAreaPart 	areaPart := aAreaPart.</body>

<body package="ChromiumEmbeddedFramework-UI">browser	" this will be populated in #onAfterCreated, not immediately "		^ browser</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>externals</category>

<body package="ChromiumEmbeddedFramework-UI">browserSettings	^ self externalAt: #browserSettings ifAbsentPut: [ self createBrowserSettings ]</body>

<body package="ChromiumEmbeddedFramework-UI">windowInfo	^ self externalAt: #windowInfo ifAbsentPut: [ self createWindowInfo ]</body>
</methods>

<methods>
<class-id>CEF.Client</class-id> <category>lifecycle-private</category>

<body package="ChromiumEmbeddedFramework-UI">doStart	MainApp ensureIsRunning.	self startBrowser.</body>

<body package="ChromiumEmbeddedFramework-UI">doStop	self browser ifNotNil: [ :b |b stop ].</body>

<body package="ChromiumEmbeddedFramework-UI">startBrowser	| win client browserSettings |	win := self windowInfo.	client := self cefObject.	browserSettings := self browserSettings.	self lib cef_browser_host_create_browser: win with: client with: nil with: browserSettings with: nil.</body>
</methods>

<methods>
<class-id>CEF.Client class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_client_t</body>
</methods>

<methods>
<class-id>CEF.Client class</class-id> <category>private-events</category>

<body package="ChromiumEmbeddedFramework-UI">constructEventsTriggered	^super constructEventsTriggered		add: #createdBrowser;		add: #loading;		add: #loaded;		add: #loadError;		yourself</body>
</methods>

<methods>
<class-id>CEF.Client class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">areaPart: aAreaPart 	^ self onNewObject areaPart: aAreaPart;		yourself</body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>externals</category>

<body package="ChromiumEmbeddedFramework-UI">browserWindowHandle	^ self externalAt: #browserWindowHandle </body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>events</category>

<body package="ChromiumEmbeddedFramework-UI">resized	self isRunning 		ifTrue: [ self mainApp schedule: ( ResizeWork browser: self )].</body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">canGoBack	^ ( self call: #'can_go_back' ) cefAsBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">canGoForward	^ ( self call: #'can_go_forward' ) cefAsBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">client	^ client</body>

<body package="ChromiumEmbeddedFramework-UI">goBack	self call: #'go_back'.</body>

<body package="ChromiumEmbeddedFramework-UI">goForward	self call: #'go_forward'.</body>

<body package="ChromiumEmbeddedFramework-UI">host	^ BrowserHost on: ( self call: #'get_host' )</body>

<body package="ChromiumEmbeddedFramework-UI">isLoading	^ ( self call: #'is_loading' ) cefAsBoolean</body>

<body package="ChromiumEmbeddedFramework-UI">mainFrame	^ ( self call: #'get_main_frame' ) ifNotNil: [: cefFrame | Frame on: cefFrame ]</body>

<body package="ChromiumEmbeddedFramework-UI">reload	self call: #reload.</body>

<body package="ChromiumEmbeddedFramework-UI">stopLoad	self call: #'stop_load'.</body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">browserRectangle	^ self client browserRectangle</body>

<body package="ChromiumEmbeddedFramework-UI">client: aClient 	client := aClient.	lifecycle := #running.</body>

<body package="ChromiumEmbeddedFramework-UI">getBrowserWindowHandle	^ ( self call: #'get_host' ) cefCall: #'get_window_handle'</body>

<body package="ChromiumEmbeddedFramework-UI">initializeWrapped	super initializeWrapped.	self externalAt: #browserWindowHandle put: self getBrowserWindowHandle.</body>

<body package="ChromiumEmbeddedFramework-UI">mainWindow	^ self client mainWindow</body>

<body package="ChromiumEmbeddedFramework-UI">resizeBrowser	| rectangle |	rectangle := self browserRectangle.	self osLib 		cefSetWindowPos: self browserWindowHandle		insertAfter: nil		x: rectangle left		y: rectangle top		cx: rectangle width		cy: rectangle height		flags: self lib SWP_ASYNCWINDOWPOS + self lib SWP_NOREDRAW + self lib SWP_NOACTIVATE 				+ self lib SWP_NOMOVE + self lib SWP_NOZORDER.	self host notifyMoveOrResizeStarted.	</body>
</methods>

<methods>
<class-id>CEF.Browser</class-id> <category>lifecycle-private</category>

<body package="ChromiumEmbeddedFramework-UI">doStart	" done by the client "</body>

<body package="ChromiumEmbeddedFramework-UI">doStop	self isAlive		ifTrue: [ self host tryCloseBrowser ].	self browserWindowHandle ifNotNil: 		[: handle |			self osLib cefDestroyWindow: handle.			self removeExternalAt: #browserWindowHandle		].</body>
</methods>

<methods>
<class-id>CEF.Browser class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">client: aClient 	^ self new client: aClient; yourself</body>
</methods>

<methods>
<class-id>CEF.Browser class</class-id> <category>private-events</category>

<body package="ChromiumEmbeddedFramework-UI">constructEventsTriggered	^super constructEventsTriggered		add: #closing;		yourself</body>
</methods>

<methods>
<class-id>CEF.Browser class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_browser_t</body>
</methods>

<methods>
<class-id>CEF.BrowserAreaPart</class-id> <category>bounds accessing</category>

<body package="ChromiumEmbeddedFramework-UI">bounds: aRectangle	super bounds: aRectangle.	self triggerEvent: #resized</body>

<body package="ChromiumEmbeddedFramework-UI">globalBounds	| translation |	translation := self localPointToGlobal: 0 @ 0.	^ self bounds translatedBy: translation</body>

<body package="ChromiumEmbeddedFramework-UI">preferredExtent	^ Point zero </body>
</methods>

<methods>
<class-id>CEF.BrowserAreaPart</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">release	self triggerEvent: #released.	super release.</body>
</methods>

<methods>
<class-id>CEF.BrowserAreaPart class</class-id> <category>private-events</category>

<body package="ChromiumEmbeddedFramework-UI">constructEventsTriggered	^super constructEventsTriggered		add: #resized;		add: #released;		yourself</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>aspects</category>

<body package="ChromiumEmbeddedFramework-UI">areaPart	areaPart isNil 		ifTrue: [ areaPart := BrowserAreaPart new ].	^ areaPart</body>

<body package="ChromiumEmbeddedFramework-UI">urlAspect	urlAspect isNil 		ifTrue: [ urlAspect := self class defaultURL asValue ].	^ urlAspect</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>actions</category>

<body package="ChromiumEmbeddedFramework-UI">goBack	self browser goBack</body>

<body package="ChromiumEmbeddedFramework-UI">goForward	self browser goForward.</body>

<body package="ChromiumEmbeddedFramework-UI">stopLoad	self browser stopLoad</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">browser	^ client browser</body>

<body package="ChromiumEmbeddedFramework-UI">registerEvents	client when: #loading do: [: frame : transitionType | self loading: frame ].	client when: #loaded do: [: frame : statusCode | self loaded: frame statusCode: statusCode ].	client 		when: #loadError		do: [: frame : errorCode : errorUrl : errorText | self loadError: frame errorCode: errorCode errorUrl: errorUrl errorText: errorText ].	client when: #createdBrowser do: [ self loadUrl ].</body>

<body package="ChromiumEmbeddedFramework-UI">startBrowser	client := Client areaPart: self areaPart.	self registerEvents.	self urlColor: ColorValue darkGray.	client start.</body>

<body package="ChromiumEmbeddedFramework-UI">urlColor: aColor 	| widget lookPreferences |	widget := self wrapperAt: #urlAspect.	lookPreferences := widget lookPreferences.	lookPreferences setBackgroundColor: aColor.	widget lookPreferences: lookPreferences.	widget invalidate.</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>interface opening</category>

<body package="ChromiumEmbeddedFramework-UI">postBuildWith: aBuilder 	| win |	super postBuildWith: aBuilder.	( win := aBuilder window ) notNil 		ifTrue: 		[				[					[( client isNil and: [ win isOpen ]) 						ifTrue: [ self startBrowser ]				] uiEventFor: win			] forkAt: Processor activeProcess priority - 1		].</body>
</methods>

<methods>
<class-id>CEF.BrowserUI</class-id> <category>events</category>

<body package="ChromiumEmbeddedFramework-UI">loaded: frame statusCode: statusCode 	| color |	Log debugLog: [ 'Loaded ' , frame url , ', status code ' , statusCode printString ].	frame isMain 		ifTrue: 		[	frame name ifNotNil: [: framename | self mainWindow label: framename ].			color := ( statusCode = 200 or: [ statusCode = 0 ]) 					ifTrue: [ ColorValue white ]					ifFalse: [ ColorValue orange ].			self urlColor: color		].</body>
</methods>

<methods>
<class-id>CEF.BrowserUI class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">defaultURL	^ DefaultURL ifNil: [ 'https://bitbucket.org/chromiumembedded/cef' ]</body>

<body package="ChromiumEmbeddedFramework-UI">defaultURL: anURIOrString	DefaultURL := anURIOrString asString</body>
</methods>

<methods>
<class-id>CEF.MainMessageLoop</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">initialize	loopSemaphore := Semaphore new.	scheduledWork := SortedCollection sortBlock: [: w1 : w2 | w1 targetTime &lt;= w2 targetTime ].	scheduleLock := RecursionLock new.</body>

<body package="ChromiumEmbeddedFramework-UI">start	" cef_run_message_loop wants to run on the main thread, which does not suit VW.	Thus use cef_do_message_loop_work here "	messageProcess :=		[				[ self doMessageLoopWork ] repeat.			messageProcess := nil		] forkAt: Processor userBackgroundPriority.	messageProcess name: 'CEF message loop'.</body>

<body package="ChromiumEmbeddedFramework-UI">stop	( messageProcess notNil and: [ messageProcess isTerminated not ]) 		ifTrue: 		[	messageProcess terminate.			messageProcess := nil		].</body>
</methods>

<methods>
<class-id>CEF.MainMessageLoop</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">minimalDelay	" do not set this value too low, which results in choppy updates or frequent crashes "		^ minimalDelay ifNil: [ 20 ]</body>

<body package="ChromiumEmbeddedFramework-UI">minimalDelay: anInteger 	minimalDelay := anInteger.</body>
</methods>

<methods>
<class-id>CEF.MainMessageLoop</class-id> <category>scheduling</category>

<body package="ChromiumEmbeddedFramework-UI">schedule: work 	" Schedule the work based on the delay.	Similar work is compressed to avoid unnecessary updates.	A minimal delay is enforced to avoid overload "	self schedule: work now: Time millisecondClockValue</body>
</methods>

<methods>
<class-id>CEF.MainMessageLoop</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">doMessageLoopWork	| work |	loopSemaphore wait.	work := scheduleLock critical: 			[	scheduledWork notEmpty 					ifTrue: [ scheduledWork removeFirst ]					ifFalse: [ nil ]			].	work notNil 		ifTrue: 		[	work isScheduled: false.			work doWork		].</body>

<body package="ChromiumEmbeddedFramework-UI">schedule: work now: now	" Schedule the work based on the delay.	Similar work is compressed to avoid unnecessary updates.	A minimal delay is enforced to avoid overload.		'now' is passed as an argument to make debugging test cases easier "	| targetTime timer minDelay |	targetTime := now + work delay.	minDelay := self minimalDelay.	" restrict update frequency "	targetTime := (targetTime / minDelay) ceiling * minDelay.	work targetTime: targetTime.	" avoid duplicate updates "	scheduleLock critical: 		[( scheduledWork includes: work ) 				ifFalse: 				[	scheduledWork add: work.					work isScheduled: true.					timer := Timer after: ( targetTime - now ) milliseconds signal: loopSemaphore.					work timer: timer				]		].</body>
</methods>

<methods>
<class-id>CEF.MainMessageLoop class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">new	^ super new initialize</body>
</methods>

<methods>
<class-id>CEF.Log</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">debug	^ debug ifNil: [ true ]</body>

<body package="ChromiumEmbeddedFramework-UI">debug: aBoolean 	debug := aBoolean.</body>

<body package="ChromiumEmbeddedFramework-UI">debugLog: aStringOrBlock 	self debug 		ifTrue: [ self addToQueue: aStringOrBlock level: 'CEF-DEBUG' ].</body>

<body package="ChromiumEmbeddedFramework-UI">warnLog: aStringOrBlock 	logQueue nextPut: 'CEF-WARNING' -&gt; aStringOrBlock</body>
</methods>

<methods>
<class-id>CEF.Log</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">initialize	logQueue := SharedQueue new.</body>

<body package="ChromiumEmbeddedFramework-UI">start	logProcess :=		[				[ self showEntry: logQueue next ] repeat		] fork.	logProcess name: 'CEF log process'.</body>

<body package="ChromiumEmbeddedFramework-UI">stop	( logProcess notNil and: [ logProcess isTerminated not ]) 		ifTrue: 		[	logProcess terminate.			logProcess := nil		].</body>
</methods>

<methods>
<class-id>CEF.Log</class-id> <category>private</category>

<body package="ChromiumEmbeddedFramework-UI">addToQueue: aStringOrBlock level: levelString 	| string |	string := aStringOrBlock isCharacters 			ifTrue: [ aStringOrBlock ]			ifFalse: [ aStringOrBlock value ].	logQueue nextPut: 'CEF-DEBUG' -&gt; string.</body>

<body package="ChromiumEmbeddedFramework-UI">logStringForEntry: entry 	| stream |	stream := String new writeStream.	stream		cr;		nextPutAll: '['; 		nextPutAll: entry key; 		nextPutAll: '] '; 		nextPutAll: Time now shortPrintString; 		nextPutAll: ' '; 		nextPutAll: entry value; 		cr.	^ stream contents</body>

<body package="ChromiumEmbeddedFramework-UI">showEntry: entry 	| logString |	" write to Stdout as one entry, so create a temporary string first, then write to Sdtout "	logString := self logStringForEntry: entry.	Stdout nextPutAll: logString; flush.</body>
</methods>

<methods>
<class-id>CEF.Log class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">current	current isNil 		ifTrue: 		[	current := self new.			current start		].	^ current</body>

<body package="ChromiumEmbeddedFramework-UI">new	^super new initialize</body>

<body package="ChromiumEmbeddedFramework-UI">stop	current notNil 		ifTrue: 		[	current stop.			current := nil		].</body>
</methods>

<methods>
<class-id>CEF.Log class</class-id> <category>logging</category>

<body package="ChromiumEmbeddedFramework-UI">debugLog: aStringOrBlock 	self current debugLog: aStringOrBlock.</body>

<body package="ChromiumEmbeddedFramework-UI">warnLog: aStringOrBlock 	self current warnLog: aStringOrBlock </body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>factory</category>

<body package="ChromiumEmbeddedFramework-UI">createMainArgs	| mainArgs hinstance |	hinstance := self osLib cefGetHInstance.	hinstance isValid 		ifFalse: [ self error: 'Could not get HINSTANCE' ].	mainArgs := self lib cef_main_args_t malloc.	mainArgs memberAt: #instance put: hinstance.	^ mainArgs</body>

<body package="ChromiumEmbeddedFramework-UI">createSettings	| settings level |	settings := Settings onNewObject.	settings singleProcess: true.	settings multiThreadedMessageLoop: true.	settings noSandbox: true.	settings externalMessagePump: true.	settings multiThreadedMessageLoop: true.	settings userAgent: 'VW Chromium'.	self logFilename 		ifNotNil: [: filename | settings logFile: filename asFilename asAbsoluteFilename asString ].	level := self debug 			ifTrue: [ #'LOGSEVERITY_VERBOSE' ]			ifFalse: [ #'LOGSEVERITY_DEFAULT' ].	settings logSeverity: level.	^ settings</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>logging</category>

<body package="ChromiumEmbeddedFramework-UI">logFilename	^ nil	"^ 'cef.' , Time secondClock displayString , '.log'"</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>message loop</category>

<body package="ChromiumEmbeddedFramework-UI">messageLoop	^ messageLoop </body>

<body package="ChromiumEmbeddedFramework-UI">restartMessageLoop	messageLoop notNil ifTrue: [ messageLoop stop ].	self initializeMessageLoop.	self runMessageLoop.</body>

<body package="ChromiumEmbeddedFramework-UI">runMessageLoop	self messageLoop start.</body>

<body package="ChromiumEmbeddedFramework-UI">stopMessageLoop	messageLoop notNil 		ifTrue: [ messageLoop stop ].</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>initialize-release</category>

<body package="ChromiumEmbeddedFramework-UI">initialize	super initialize.	self initializeMessageLoop.</body>

<body package="ChromiumEmbeddedFramework-UI">initializeMessageLoop	messageLoop := MainMessageLoop new.</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>lifecycle-private</category>

<body package="ChromiumEmbeddedFramework-UI">doStart	self runMessageLoop.	self initializeApp.</body>

<body package="ChromiumEmbeddedFramework-UI">doStop	self lib cef_shutdown.	Log stop.</body>

<body package="ChromiumEmbeddedFramework-UI">initializeApp	| settings initialized application mainArgs exitCode |	mainArgs := self createMainArgs.	application := self cefObject.	exitCode := self lib cef_execute_process: mainArgs with: application with: nil.	exitCode &gt;= 0 		ifTrue: [ self error: 'cef_execute_process failed with code ' , exitCode printString ].	settings := self createSettings.	initialized := self lib cef_initialize: mainArgs with: settings cefObject with: application with: nil.	initialized = 0 		ifTrue: [ self error: 'cef_initialize failed' ].</body>
</methods>

<methods>
<class-id>CEF.MainApp</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">schedule: work	self messageLoop schedule: work.</body>

<body package="ChromiumEmbeddedFramework-UI">switches	^ #( 'no-proxy-server' )</body>
</methods>

<methods>
<class-id>CEF.MainApp class</class-id> <category>instance creation</category>

<body package="ChromiumEmbeddedFramework-UI">current	" CEF apps are initialized once per process, so we need a singleton "		current isNil 		ifTrue: [ current := self onNewObject ].	^ current</body>

<body package="ChromiumEmbeddedFramework-UI">ensureIsRunning		self current ensureIsRunning</body>
</methods>

<methods>
<class-id>CEF.MainApp class</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">flushCurrent	current := nil.</body>

<body package="ChromiumEmbeddedFramework-UI">stop	current notNil 		ifTrue: 		[	" does nto reset current, because CEF apps can only be initialize once per OS process "			current stop		].</body>

<body package="ChromiumEmbeddedFramework-UI">typeName	^ #cef_app_t</body>
</methods>

<methods>
<class-id>External.CCompositePointer</class-id> <category>accessing</category>

<body package="ChromiumEmbeddedFramework-UI">cefAsSmalltalkArg	^ ( CEF.Base classForType: self type referentType ) 		ifNotNil: 		[: wrapperClass |			"CEF.Log debugLog: 'auto wrapping ' , wrapperClass fullName."			wrapperClass on: self isVolatile: true		]		ifNil: [ super cefAsSmalltalkArg ]</body>

<body package="ChromiumEmbeddedFramework-UI">cefRegistryKey	^ self referentAddress</body>
</methods>

<do-it>"Imported Classes:"</do-it>

<do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it>

<class>
<name>Object</name>
<environment>Core</environment>
<super></super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Kernel-Objects</category>
<attributes>
<package>Kernel-Objects</package>
</attributes>
</class>

<class>
<name>VisualPart</name>
<environment>Graphics</environment>
<super>Graphics.VisualComponent</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>container eventHandlers properties </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Graphics-Visual Objects</category>
<attributes>
<package>Graphics-Visual Objects</package>
</attributes>
</class>

<class>
<name>CCompositePointer</name>
<environment>External</environment>
<super>External.CPointer</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>External-Data</category>
<attributes>
<package>External-Data</package>
</attributes>
</class>

<class>
<name>ApplicationModel</name>
<environment>UI</environment>
<super>UI.Model</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>builder uiSession eventHandlers </inst-vars>
<class-inst-vars>savedWindowInformation </class-inst-vars>
<imports></imports>
<category>UIBuilder-Framework</category>
<attributes>
<package>UIBuilder-Framework</package>
</attributes>
</class>

</st-source>
